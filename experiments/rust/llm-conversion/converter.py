#!/usr/bin/env python3
"""Converter of protos to Rust (originally generated by xAI and modified)."""

from google.protobuf import descriptor_pb2
from google.protobuf import message
from google.protobuf import reflection
import subprocess
import click
import os


def get_proto_content(proto_file):
    """Reads the proto file and returns its content."""
    with open(proto_file, "r") as file:
        return file.read()


def compile_proto(proto_file, rootdir):
    """Compiles the proto file into descriptor set."""
    cmd = [
        "protoc",
        f"--descriptor_set_out=descriptorset.bin",
        f"--proto_path={rootdir}/beancount/ccore",
        f"--proto_path={rootdir}/beancount/cparser",
        # f"--proto_path={proto_file.rsplit('/', 1)[0]}",
        proto_file,
    ]
    subprocess.run(cmd)


def load_proto_descriptor():
    """Loads the compiled proto file's descriptor."""
    with open("descriptorset.bin", "rb") as f:
        proto_content = f.read()
    file_descriptor_set = descriptor_pb2.FileDescriptorSet.FromString(proto_content)
    return file_descriptor_set.file


def parse_proto(file_descriptors):
    """Parses the file descriptors to extract messages and enums."""
    all_messages = []
    for file_descriptor in file_descriptors:
        for message_type in file_descriptor.message_type:
            all_messages.append(parse_message(message_type))
    return all_messages


def parse_message(message_type, indent=0):
    """Recursively parses a message type into a Rust-like structure."""
    struct_name = message_type.name
    rust_struct = [f"pub struct {struct_name} {{"]

    for field in message_type.field:
        rust_struct.append(f"{'    ' * (indent + 1)}pub {field.name}: {map_type(field)},")

    for nested_type in message_type.nested_type:
        rust_struct.append(
            f"{'    ' * (indent + 1)}{parse_message(nested_type, indent + 1)}"
        )

    for enum_type in message_type.enum_type:
        rust_struct.append(f"{'    ' * (indent + 1)}{parse_enum(enum_type)}")

    rust_struct.append(f"{'    ' * indent}}}")
    return "\n".join(rust_struct)


def parse_enum(enum_type):
    """Creates a Rust enum representation."""
    enum_name = enum_type.name
    variants = [f"{enum_name} {{"]
    for value in enum_type.value:
        variants.append(f"    {value.name} = {value.number},")
    variants.append("}")
    return "\n".join(variants)


def map_type(field):
    """Maps protobuf field types to Rust types."""
    type_mapping = {
        "TYPE_DOUBLE": "f64",
        "TYPE_FLOAT": "f32",
        "TYPE_INT64": "i64",
        "TYPE_UINT64": "u64",
        "TYPE_INT32": "i32",
        "TYPE_FIXED64": "u64",
        "TYPE_FIXED32": "u32",
        "TYPE_BOOL": "bool",
        "TYPE_STRING": "String",
        "TYPE_MESSAGE": field.message_type.name,
        "TYPE_BYTES": "Vec<u8>",
    }
    return type_mapping.get(field.type_name, "Option<Box<dyn Any>>")


@click.command()
@click.option(
    "--proto-file",
    type=click.Path(exists=True),
    required=True,
    help="Path to the .proto file.",
)
@click.option(
    "--output-file",
    type=click.Path(writable=True),
    default="rust_structs.rs",
    help="Path to save the generated Rust structures.",
)
def main(proto_file: str, output_file: str | None):
    compile_proto(proto_file, os.getcwd())
    file_descriptors = load_proto_descriptor()
    messages = parse_proto(file_descriptors)

    with open(output_file, "w") as file:
        for message in messages:
            file.write(message + "\n\n")


if __name__ == "__main__":
    main()
